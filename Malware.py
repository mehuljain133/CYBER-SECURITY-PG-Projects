# Unit-IV Introduction to Malware, Malware Analysis: Static Analysis, Code Review, Dynamic Analysis, Behavioral analysis of malicious executable, Sandbox Technologies, Reverse-engineering malware, Defeat anti-reverse engineering technique, automated analysis, intercepting network connections, Network flow analysis, Malicious Code Analysis, Network analysis, Anti-disassembling techniques, Identifying assembly logic structures with a disassembler.Malware Handling: Malicious Documents and Memory Forensics - Reverse engineering of malicious executable using memory forensic techniques, Analyze malicious Microsoft Office (Word, Excel, PowerPoint) and Adobe PDF documents, Analyzing memory to assess malware characteristics and reconstruct infection artifacts. Using memory forensics to analyze rootkit infections, Legal & Ethical Issues - Reinforce understanding and the application of discipline specific legal and ethical issues, Reverse Engineering Malware (REM) Methodology.

# Cyber Security - Unit IV: Malware Analysis & Memory Forensics Simulator

import time
import random

class MalwareSimulator:
    def __init__(self):
        self.topics = {
            1: ("Introduction to Malware", self.intro_malware),
            2: ("Static Analysis", self.static_analysis),
            3: ("Dynamic Analysis", self.dynamic_analysis),
            4: ("Behavioral Analysis", self.behavior_analysis),
            5: ("Sandbox Technologies", self.sandbox),
            6: ("Reverse Engineering & Anti-RE Techniques", self.reverse_engineering),
            7: ("Network Interception & Flow Analysis", self.network_analysis),
            8: ("Malicious Code Analysis", self.code_analysis),
            9: ("Anti-disassembly Techniques", self.anti_disassembly),
            10: ("Memory Forensics & Rootkit Detection", self.memory_forensics),
            11: ("Malicious Documents Analysis", self.malicious_docs),
            12: ("Legal & Ethical Issues", self.legal_ethics),
            13: ("REM Methodology", self.rem_methodology)
        }

    def run(self):
        print("=== UNIT-IV: Malware Analysis Simulator ===")
        while True:
            for k, (title, _) in self.topics.items():
                print(f"{k}. {title}")
            print("0. Exit")

            try:
                choice = int(input("\nSelect a topic (0 to Exit): "))
                if choice == 0:
                    print("Exiting malware simulation. Stay secure.")
                    break
                elif choice in self.topics:
                    print(f"\n--- {self.topics[choice][0]} ---")
                    self.topics[choice][1]()
                    print("\n--- End ---\n")
                else:
                    print("Invalid input.")
            except ValueError:
                print("Enter a valid number.")

    # === Simulations ===

    def intro_malware(self):
        types = ["Virus", "Worm", "Trojan", "Ransomware", "Spyware", "Rootkit"]
        for t in types:
            print(f"üì¶ Malware Type: {t}")
            time.sleep(0.5)

    def static_analysis(self):
        print("üîç Performing Static Analysis...")
        print("‚Ä¢ No execution required.")
        print("‚Ä¢ Tools: Strings, PEiD, binwalk, Ghidra")
        print("‚Ä¢ Findings: Suspicious APIs: CreateRemoteThread, WriteProcessMemory")

    def dynamic_analysis(self):
        print("‚öôÔ∏è Executing malware in sandbox...")
        print("‚Ä¢ Monitoring behavior: Registry changes, file drops, network activity")
        print("‚Ä¢ Dynamic artifacts captured.")

    def behavior_analysis(self):
        print("üìà Behavioral fingerprint:")
        print("- Drops hidden .dll into temp folder")
        print("- Attempts outbound HTTP to 23.45.67.89")
        print("- Creates auto-start registry key")

    def sandbox(self):
        print("üß™ Using sandbox technologies:")
        print("- Cuckoo Sandbox, Any.Run, FireEye")
        print("‚Ä¢ Ensures isolation for safe testing.")

    def reverse_engineering(self):
        print("üõ† Reverse Engineering using Ghidra/IDA Pro...")
        print("‚Ä¢ Decompiled functions: main(), decrypt_key(), connect_cnc()")
        print("‚Ä¢ Anti-debugging: IsDebuggerPresent(), timing checks")

    def network_analysis(self):
        print("üåê Intercepting traffic...")
        print("‚Ä¢ Network flow: infected.exe ‚Üí C2 server (port 8080)")
        print("‚Ä¢ Analysis using Wireshark/Netsniff-ng")

    def code_analysis(self):
        print("üîß Code contains:")
        print("- XOR encryption routines")
        print("- Base64 encoded payloads")
        print("- Self-modifying code sections")

    def anti_disassembly(self):
        print("‚õî Anti-disassembly detected:")
        print("- Junk code insertion")
        print("- Function pointer obfuscation")
        print("‚Ä¢ IDA workaround: Linear sweep + manual re-analysis")

    def memory_forensics(self):
        print("üß† Analyzing memory image...")
        print("- Tool: Volatility")
        print("‚Ä¢ Detected injected code in svchost.exe")
        print("‚Ä¢ Rootkit hooks found in SSDT")

    def malicious_docs(self):
        print("üìÑ Office Malware Analysis:")
        print("‚Ä¢ Analyzing macros in Word: AutoOpen(), malicious shellcode")
        print("‚Ä¢ PDF objects containing JavaScript payload")

    def legal_ethics(self):
        print("‚öñÔ∏è Legal & Ethical Guidelines:")
        print("- Follow GDPR and cybersecurity laws")
        print("- Never analyze live malware on production systems")
        print("- Always obtain consent before handling client data")

    def rem_methodology(self):
        steps = [
            "1. Identify malware type",
            "2. Isolate sample",
            "3. Perform static analysis",
            "4. Perform dynamic analysis",
            "5. Extract indicators of compromise",
            "6. Document findings"
        ]
        print("üß© Reverse Engineering Malware (REM) Methodology:")
        for step in steps:
            print(step)
            time.sleep(0.6)

# Run the simulator
if __name__ == "__main__":
    sim = MalwareSimulator()
    sim.run()
